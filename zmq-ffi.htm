A few months ago I released ZMQ::FFI, zeromq bindings for Perl that use FFI::Raw instead of XS. There's been some interest, so I thought I would write a short post to announce the module beyond the zeromq mailing list.

In another post I'll discuss FFI::Raw itself, what it currently provides, as well as some advanced use cases that came up during the development of ZMQ::FFI. If reverse depends on metacpan is anything to go by, it seems many people aren't aware of this module. In fact, at the time of this writing ZMQ::FFI is the only module using it:

<img alt="ffi-raw-reverse-depends.png" src="http://blogs.perl.org/users/dylan_cali/2014/01/19/ffi-raw-reverse-depends.png" width="599" height="128" class="mt-image-none" style="" />
That's a shame, as it's a terrific module which finally makes FFI in Perl feasible. It effectively eliminates the need for XS in many cases, and it's sufficiently baked to be considered "production ready."

<big><big>ZMQ::FFI</big></big>

This post assumes existing knowledge of zeromq. If you have no idea what zeromq is, or what it's used for, you can get started <a href="https://en.wikipedia.org/wiki/zeromq">here</a> and <a href="http://zeromq.org/">here</a>.

The description for ZMQ::FFI is already pretty concise, so let's start with that:

<blockquote>ZMQ::FFI exposes a high level, transparent, OO interface to zeromq independent of the underlying libzmq version. Where semantics differ, it will dispatch to the appropriate backend for you. As it uses ffi, there is no dependency on XS or compilation.</blockquote>


What this means in practice is that it doesn't matter if you have zeromq 2/3/4 installed; you can use the same consistent interface. To demonstrate this, as well as ZMQ::FFI's basic usage, let's start with a simple send/recv example:

<pre>sendrecv1.pl</pre>

<pre><code>use ZMQ::FFI;
use ZMQ::FFI::Constants qw(ZMQ_REQ ZMQ_REP);

my $endpoint = "ipc://zmq-ffi-$$";
my $ctx      = ZMQ::FFI->new();
my $version  = join '.', $ctx->version;

my $req = $ctx->socket(ZMQ_REQ);
$req->connect($endpoint);

my $rep = $ctx->socket(ZMQ_REP);
$rep->bind($endpoint);

$req->send($version);
say $rep->recv();
</code></pre>

Pretty basic: we setup a simple request/reply connection, send the libzmq version string as the message, receive it, and print it. <code>$ctx->version()</code> returns a list of
<code>($major, $minor, $patch)</code> and hence the <code>join</code>.

On my Arch Linux box with zeromq 4.0.3 installed I get:

<pre>$ perl sendrecv1.pl
4.0.3
</pre>

As expected.

Now what if an older libzmq version is installed? Say 2.x which has an incompatible ABI. I can simulate this by setting my LD_LIBRARY_PATH to the location of the older .so:

<pre>$ ls ~/git/zeromq2-x/src/.libs/libzmq.so*
/home/calid/git/zeromq2-x/src/.libs/libzmq.so
/home/calid/git/zeromq2-x/src/.libs/libzmq.so.1
/home/calid/git/zeromq2-x/src/.libs/libzmq.so.1.0.1
$ export LD_LIBRARY_PATH=~/git/zeromq2-x/src/.libs/
$ perl sendrecv1.pl
2.2.1
</pre>

Success. I was able to reuse the same code and ZMQ::FFI was able to gracefully handle the ABI differences between versions.

It's important to point out that contexts are isolated from one another, ensuring you can have several in the same process without issue. In fact, it's even possible to create contexts using different zeromq versions:

<pre>sendrecv2.pl</pre>

<pre><code>use ZMQ::FFI;
use ZMQ::FFI::Constants qw(ZMQ_REQ ZMQ_REP);

my $endpoint = "ipc://zmq-ffi-$$";

# send using 2.x context
my $req_ctx     = ZMQ::FFI->new( soname => 'libzmq.so.1' );
my $req_version = join '.', $req_ctx->version;

my $req = $req_ctx->socket(ZMQ_REQ);
$req->connect($endpoint);
$req->send($req_version);

# receive using 4.x context
my $rep_ctx     = ZMQ::FFI->new( soname => 'libzmq.so.3' );
my $rep_version = join '.', $rep_ctx->version;

my $rep = $rep_ctx->socket(ZMQ_REP);
$rep->bind($endpoint);

say join " ",
    $rep_version, "context",
    "received message from",
    $rep->recv(), "context";
</code></pre>

<pre>$ perl sendrecv2.pl
4.0.3 context received message from 2.2.1 context
</pre>

Using the <em>soname</em> attribute I've explicitly indicated the libzmq.so I want to use to create each context. If the .so doesn't already exist on your ld path manually adding it via LD_LIBRARY_PATH is one option, but you can also reference it directly using an absolute path. So in the example above if I change

<pre><code>ZMQ::FFI->new( soname => 'libzmq.so.3' )</code></pre>

to

<pre><code>ZMQ::FFI->new( soname => '/home/calid/git/zeromq3-x/src/.libs/libzmq.so' )</code></pre>

my output changes to:

<pre>$ perl sendrecv2.pl
3.2.5 context received message from 2.2.1 context
</pre>

Being able to set the soname is especially useful when you have parallel zeromq installations, all on your ld path. The first version found may not be the one you actually want to use. By explicitly setting the soname you can eliminate any ambiguity.

This extends to zeromq 3 vs zeromq 4 which have the same major soname (libzmq.so.3). The solution here is to specify the complete soname, major.minor.patch:

<pre><code>my $req_ctx = ZMQ::FFI->new( soname => 'libzmq.so.3.0.0' );
...
my $rep_ctx = ZMQ::FFI->new( soname => 'libzmq.so.3.1.0' );
</code></pre>

<pre>$ perl sendrecv2.pl
4.0.3 context received message from 3.2.5 context
</pre>

The identical soname is a result of zeromq 4 having an ABI that is backward compatible with zeromq 3.

