A few months ago I released zeromq bindings for Perl that use FFI::Raw insteadof XS. There's been some interest, so I thought I would write a short post toannounce the module beyond the zeromq mailing list. It will also give me achance to talk about FFI::Raw and what it brings to the table. If reversedepends on metacpan is anything to go by, it seems many people aren't aware ofor using this module. At the time of this writing ZMQ::FFI is the only modulethat depends on it:

<img alt="ffi-raw-reverse-depends.png" src="http://blogs.perl.org/users/dylan_cali/2014/01/19/ffi-raw-reverse-depends.png" width="599" height="128" class="mt-image-none" style="" />

That's a shame, as it's a terrific module which finally makes FFI in Perl feasible. It effectively eliminates the needfor XS in many cases.

<big>ZMQ::FFI</big>

This post assumes existing knowledge of zeromq. If you have no idea what zeromq is, or what it's used for, here are somelinks to get you started:

<ul>
    <li>https://en.wikipedia.org/wiki/zeromq</li>
    <li>http://zeromq.org/</li>
</ul>

The description for ZMQ::FFI is already pretty concise, so let's start with that:

<blockquote>ZMQ::FFI exposes a high level, transparent, OO interface to zeromqindependent of the underlying libzmq version. Where semantics differ, it willdispatch to the appropriate backend for you. As it uses ffi, there is nodependency on XS or compilation.</blockquote>

What this means in practice is that it doesn't matter if you have zeromq 2/3/4installed, you can use the same consistent interface. To demonstrate this, aswell as ZMQ::FFI's basic usage, let's start with a simple send/recv example:

<pre><code># sendrecv1.pl

use v5.10;
use ZMQ::FFI;
use ZMQ::FFI::Constants qw(ZMQ_REQ ZMQ_REP);

my $endpoint = "ipc://zmq-ffi-$$";
my $ctx      = ZMQ::FFI->new();
my $version  = join '.', $ctx->version;

my $req = $ctx->socket(ZMQ_REQ);
$req->connect($endpoint);

my $rep = $ctx->socket(ZMQ_REP);
$rep->bind($endpoint);

$req->send($version);
say $rep->recv();
</code></pre>

Pretty basic: we setup a simple request/reply connection, send the libzmqversion string as the message, receive it, and print it.<code>$ctx->version()</code> returns a list of <code>($major, $minor, $patch)</code>,hence the <code>join</code>.

On my Arch Linux box with zeromq 4.0.3 installed I get:

<pre>$ perl sendrecv1.pl
4.0.3
</pre>

As expected.

Now what if an older libzmq version is installed? Say 2.x which has anincompatible ABI. I can simulate this by setting my LD_LIBRARY_PATH to thelocation on disk with the older .so:

<pre>$ ls ~/git/zeromq2-x/src/.libs/libzmq.so*
/home/calid/git/zeromq2-x/src/.libs/libzmq.so
/home/calid/git/zeromq2-x/src/.libs/libzmq.so.1
/home/calid/git/zeromq2-x/src/.libs/libzmq.so.1.0.1
$ export LD_LIBRARY_PATH=~/git/zeromq2-x/src/.libs/
$ perl sendrecv1.pl
2.2.1
</pre>

Success. I was able to reuse the same code and ZMQ::FFI was able to gracefullyhandle the ABI differences between versions.

It's important to point out that contexts are isolated from one another,ensuring that you can have multiple contexts in the same process. In fact, it'seven possible to have multiple contexts using different zeromq versions:

<pre><code>#sendrecv2.pl

use v5.10;
use ZMQ::FFI;
use ZMQ::FFI::Constants qw(ZMQ_REQ ZMQ_REP);

my $endpoint = "ipc://zmq-ffi-$$";

# send request using 2.x context
my $req_ctx     = ZMQ::FFI->new( soname => 'libzmq.so.1' );
my $req_version = join '.', $req_ctx->version;

my $req = $req_ctx->socket(ZMQ_REQ);
$req->connect($endpoint);
$req->send($req_version);

# receive reply using 4.x context
my $rep_ctx     = ZMQ::FFI->new( soname => 'libzmq.so.3' );
my $rep_version = join '.', $rep_ctx->version;

my $rep = $rep_ctx->socket(ZMQ_REP);
$rep->bind($endpoint);

say join " ",
    $rep_version, "context",
    "received message from",
    $rep->recv(), "context";
</code></pre>

<pre>$ perl sendrecv2.pl
4.0.3 context received message from 2.2.1 context
</pre>

Using the <code>soname</code> attribute I've explicitly indicated the libzmq.soI want to use to create each context. If the .so doesn't exist on your ld pathyou can reference it using an absolute path instead of manually setting theLD_LIBRARY_PATH env var. So in the example above if I change<code>libzmq.so.3</code> to<code>/home/calid/git/zeromq3-x/src/.libs/libzmq.so</code>, my output changesto:

<pre>$ perl sendrecv2.pl
3.2.5 context received message from 2.2.1 context
</pre>

Being able to set the soname is especially useful when you have parallel zeromqinstallations, all on your ld path. The first version found may not be theversion you actually want to use. By explicitly setting the soname you caneliminate any ambiguity.

This extends to zeromq 3 vs zeromq 4 which have the same major soname(libzmq.so.3). The solution here is to specify the complete soname(major.minor.patch):

<pre><code>
my $req_ctx = ZMQ::FFI->new( soname => 'libzmq.so.3.0.0' );
...
my $rep_ctx = ZMQ::FFI->new( soname => 'libzmq.so.3.1.0' );
</code></pre>

<pre>$ perl sendrecv2.pl
4.0.3 context received message from 3.2.5 context
</pre>

The identical soname is because zeromq 4 has an ABI that is backward compatiblewith zeromq 3.

